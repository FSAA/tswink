<?php

namespace TsWink\Classes\Expressions;

use Illuminate\Database\Eloquent\Relations\Relation;
use ReflectionClass;
use ReflectionMethod;
use ReflectionNamedType;
use Exception;
use Illuminate\Database\Eloquent\Model;

class ClassExpression extends Expression
{
    /** @var string */
    public $namespace;

    /** @var ImportExpression[] */
    public $imports = [];

    /** @var string */
    public $nonAutoGeneratedImports;

    /** @var string */
    public $baseClassName;

    /** @var string */
    public $name;

    /** @var ClassMemberExpression[] */
    public $members = [];

    /** @var string */
    public $nonAutoGeneratedClassDeclarations;

    /** @var EloquentRelation[] */
    public $eloquentRelations = [];

    public static function tryParse(string $text, ?ClassExpression &$result): bool
    {
        $class = new ClassExpression();
        $matches = null;
        $line = strtok($text, "\r\n");
        while ($line !== false) {
            preg_match('/namespace\\n* *(.+)\\n*;/', $line, $matches);
            if (count($matches) > 0) {
                $class->namespace = $matches[1];
            }
            preg_match('/class\\n* *([a-zA-Z_]+[a-zA-Z0-9_]*) *extends *([a-zA-Z_]+[a-zA-Z0-9_]*)/', $line, $matches);
            if (count($matches) > 1) {
                $class->name = $matches[1];
                $class->baseClassName = $matches[2];
            }
            $classMember = null;
            if (ClassMemberExpression::tryParse($line, $classMember)) {
                $class->members[$classMember->name] = $classMember;
            }
            $line = strtok("\r\n");
        }
        if ($class->name == null) {
            return false;
        }
        if ($class->baseClassName != "Enum") {
            /** @var class-string<Model> $className */
            $className = $class->fullyQualifiedClassName();
            $class->eloquentRelations = self::parseEloquentRelations($className);

            if ($class->name !== 'BaseModel') {
                $baseModelImport = new ImportExpression();
                $baseModelImport->name = 'BaseModel';
                $baseModelImport->target = './BaseModel';
                $class->imports[] = $baseModelImport;
            }
        }
        $result = $class;
        return true;
    }

    public function hasMember(string $name): bool
    {
        return array_key_exists($name, $this->members);
    }

    /**
     * @return class-string
     */
    public function fullyQualifiedClassName(): string
    {
        $className = $this->namespace . '\\' . $this->name;
        if (class_exists($className)) {
            return $className;
        }
        throw new Exception("Class $className not found");
    }

    public function instantiate(): object
    {
        $fullyQualifiedClassName = $this->fullyQualifiedClassName();
        return new $fullyQualifiedClassName();
    }

    public function toTypeScript(ExpressionStringGenerationOptions $options): string
    {
        if ($this->baseClassName == "Enum") {
            return $this->toTypeScriptEnum($options);
        }
        return $this->toTypeScriptClass($options);
    }

    /**
     * @param class-string<Model> $className
     * @return EloquentRelation[]
     * */
    private static function parseEloquentRelations(string $className): array
    {
        $reflection = new ReflectionClass($className);
        $relations = [];
        $classInstance = new $className();
        foreach ($reflection->getMethods(ReflectionMethod::IS_PUBLIC) as $method) {
            $eloquentRelation = self::getMethodEloquentRelationName($method);
            if (!$eloquentRelation) {
                continue;
            }

            /** @var Relation<Model,Model,Model> $relationResult */
            $relationResult = $method->invoke($classInstance);
            $relation = EloquentRelation::parse([
                'relationName' => $method->getName(),
                'targetClass' => $relationResult->getRelated()::class,
                'relationType' => $eloquentRelation
            ]);
            $relations[$relation->name] = $relation;
        }
        return $relations;
    }

    private static function getMethodEloquentRelationName(ReflectionMethod $method): ?string
    {
        $returnType = $method->getReturnType();
        if (!$returnType instanceof ReflectionNamedType || $returnType->isBuiltin()) {
            return null;
        }

        $returnTypeName = $returnType->getName();
        if (!class_exists($returnTypeName)) {
            return null;
        }

        $parents = class_parents($returnTypeName);
        if (!isset($parents[Relation::class])) {
            return null;
        }
        return $returnTypeName;
    }

    private function toTypeScriptEnum(ExpressionStringGenerationOptions $options): string
    {
        $content = "export enum {$this->name} {\n";
        $enumContent = null;
        foreach ($this->members as $member) {
            if ($member->noConvert) {
                continue;
            }
            $enumContent .= $member->name . " = " . $member->initialValue . ",\n";
        }
        if ($enumContent) {
            $content .= $this->indent(trim($enumContent, "\n"), 1, $options) . "\n";
        }
        $content .= "}";
        return $content;
    }

    private function toTypeScriptClass(ExpressionStringGenerationOptions $options): string
    {
        $extends = '';
        if ($this->name !== 'BaseModel' && $this->baseClassName !== 'Enum') {
            $extends = ' extends BaseModel';
        }
        $content = null;
        foreach ($this->imports as $import) {
            $content .= $import->toTypeScript($options) . "\n";
        }
        $content .= $this->generateNonAutoGeneratedClassDeclarations();
        $content .= $this->generateExportStatement($options, $extends);
        $classBody = null;

        usort($this->members, function ($a, $b) {
            return strcmp($a->name, $b->name);
        });
        foreach ($this->members as $member) {
            if (!$member->noConvert) {
                $classBody .= $member->toTypeScript($options) . $this->generateSemicolon($options) . "\n";
            }
        }

        $classBody .= "\n";
        if (!$options->useInterfaceInsteadOfClass) {
            $classBody .= "constructor(init?: Partial<$this->name>) {\n";
            $constructorContent = '';
            if ($extends) {
                $constructorContent .= "super(init);\n";
            }
            $constructorContent .= "Object.assign(this, init);\n";
            foreach ($this->members as $member) {
                if ($member->type == null || $member->noConvert) {
                    continue;
                } elseif ($member->type->isCollection) {
                    $constructorContent .= "this." . $member->name . " = init?." . $member->name . " ? init." . $member->name . ".map(v => new " . $member->type->name . "(v)) : []" . $this->generateSemicolon($options) . "\n";
                } elseif ($member->type->name == "Date") {
                    $constructorContent .= "this." . $member->name . " = init?." . $member->name . " ? Date.parseEx(init." . $member->name . ") : undefined" . $this->generateSemicolon($options) . "\n";
                } elseif (!$member->type->isPrimitive()) {
                    $constructorContent .= "this." . $member->name . " = init?." . $member->name . " ? new " . $member->type->name . "(init." . $member->name . ") : undefined" . $this->generateSemicolon($options) . "\n";
                }
            }

            $classBody .= $this->indent(trim($constructorContent, "\n"), 1, $options) . "\n";
            $classBody .= "}\n\n";
        }
        $classBody .= "// <non-auto-generated-class-declarations>\n";
        if ($this->nonAutoGeneratedClassDeclarations) {
            $classBody .= $this->indent($this->nonAutoGeneratedClassDeclarations, -1, $options);
        }
        $classBody .= "\n";
        $classBody .= "// </non-auto-generated-class-declarations>";
        $content .= $this->indent($classBody, 1, $options) . "\n";
        $content .= "}\n";
        return $content;
    }

    private function generateExportStatement(ExpressionStringGenerationOptions $options, string $extends): string
    {
        if ($options->useInterfaceInsteadOfClass) {
            return "export default interface {$this->name}{$extends} {\n";
        }
        return "export default class {$this->name}{$extends} {\n\n";
    }

    private function generateNonAutoGeneratedClassDeclarations(): string
    {
        $content = "\n";
        $content .= "// <non-auto-generated-import-declarations>\n";
        $content .= $this->nonAutoGeneratedImports . "\n";
        $content .= "// </non-auto-generated-import-declarations>\n\n";
        return $content;
    }

    private function generateSemicolon(ExpressionStringGenerationOptions $options): string
    {
        return $options->useSemicolon ? ';' : '';
    }
}
