<?php

namespace TsWink\Classes\Expressions;

use Exception;

class ClassExpression extends Expression
{
    /** @var string */
    public $namespace;

    /** @var ImportExpression[] */
    public $imports = [];

    /** @var string */
    public $nonAutoGeneratedImports;

    /** @var string */
    public $baseClassName;

    /** @var string */
    public $name;

    /** @var ClassMemberExpression[] */
    public $members = [];

    /** @var string */
    public $nonAutoGeneratedClassDeclarations;

    /** @var EloquentRelation[] */
    public $eloquentRelations = [];

    public static function tryParse(string $text, ?ClassExpression &$result): bool
    {
        $class = new ClassExpression();
        $matches = null;
        $line = strtok($text, "\r\n");
        while ($line !== false) {
            preg_match('/namespace\\n* *(.+)\\n*;/', $line, $matches);
            if (count($matches) > 0) {
                $class->namespace = $matches[1];
            }
            preg_match('/class\\n* *([a-zA-Z_]+[a-zA-Z0-9_]*) *extends *([a-zA-Z_]+[a-zA-Z0-9_]*)/', $line, $matches);
            if (count($matches) > 1) {
                $class->name = $matches[1];
                $class->baseClassName = $matches[2];
            }
            $classMember = null;
            if (ClassMemberExpression::tryParse($line, $classMember)) {
                $class->members[$classMember->name] = $classMember;
            }
            $line = strtok("\r\n");
        }
        if ($class->name == null) {
            return false;
        }
        if ($class->baseClassName != "Enum") {
            $classInstance = $class->instantiate();
            $class->eloquentRelations = self::parseEloquentRelations($classInstance);

            if ($class->name !== 'BaseModel') {
                $baseModelImport = new ImportExpression();
                $baseModelImport->name = 'BaseModel';
                $baseModelImport->target = './BaseModel';
                $class->imports[] = $baseModelImport;
            }
        }
        $result = $class;
        return true;
    }

    public function hasMember(string $name): bool
    {
        return array_key_exists($name, $this->members);
    }

    /**
     * @return class-string
     */
    public function fullyQualifiedClassName(): string
    {
        $className = $this->namespace . '\\' . $this->name;
        if (class_exists($className)) {
            return $className;
        }
        throw new Exception("Class $className not found");
    }

    public function instantiate(): object
    {
        $fullyQualifiedClassName = $this->fullyQualifiedClassName();
        return new $fullyQualifiedClassName();
    }

    public function toTypeScript(ExpressionStringGenerationOptions $options): string
    {
        if ($this->baseClassName == "Enum") {
            return $this->toTypeScriptEnum($options);
        }
        return $this->toTypeScriptClass($options);
    }

    /** @return EloquentRelation[] */
    private static function parseEloquentRelations(object $classInstance): array
    {
        $relations = [];
        if (method_exists($classInstance, "getModelRelations") && count($classInstance->getModelRelations()) > 0) {
            foreach ($classInstance->getModelRelations() as $relation) {
                $relation = EloquentRelation::parse($relation);
                $relations[$relation->name] = $relation;
            }
        }
        return $relations;
    }

    private function toTypeScriptEnum(ExpressionStringGenerationOptions $options): string
    {
        $content = "export enum {$this->name} {\n";
        $enumContent = null;
        foreach ($this->members as $member) {
            if ($member->noConvert) {
                continue;
            }
            $enumContent .= $member->name . " = " . $member->initialValue . ",\n";
        }
        if ($enumContent) {
            $content .= $this->indent(trim($enumContent, "\n"), 1, $options) . "\n";
        }
        $content .= "}";
        return $content;
    }

    private function toTypeScriptClass(ExpressionStringGenerationOptions $options): string
    {
        $extends = '';
        if ($this->name !== 'BaseModel' && $this->baseClassName !== 'Enum') {
            $extends = ' extends BaseModel';
        }
        $content = null;
        foreach ($this->imports as $import) {
            $content .= $import->toTypeScript($options) . "\n";
        }
        $content .= "// <non-auto-generated-import-declarations>\n";
        $content .= $this->nonAutoGeneratedImports . "\n";
        $content .= "// </non-auto-generated-import-declarations>\n\n";
        $content .= "export default class {$this->name}{$extends} {\n\n";
        $classBody = null;

        usort($this->members, function ($a, $b) {
            return strcmp($a->name, $b->name);
        });
        foreach ($this->members as $member) {
            if (!$member->noConvert) {
                $classBody .= $member->toTypeScript($options) . ";\n";
            }
        }

        $classBody .= "\n";
        $classBody .= "constructor(init?: Partial<$this->name>) {\n";
        $constructorContent = '';
        if ($extends) {
            $constructorContent .= "super(init);\n";
        }
        $constructorContent .= "Object.assign(this, init);\n";
        foreach ($this->members as $member) {
            if ($member->type == null || $member->noConvert) {
                continue;
            } elseif ($member->type->isCollection) {
                $constructorContent .= "this." . $member->name . " = init?." . $member->name . " ? init." . $member->name . ".map(v => new " . $member->type->name . "(v)) : [];\n";
            } elseif ($member->type->name == "Date") {
                $constructorContent .= "this." . $member->name . " = init?." . $member->name . " ? Date.parseEx(init." . $member->name . ") : undefined;\n";
            } elseif (!$member->type->isPrimitive()) {
                $constructorContent .= "this." . $member->name . " = init?." . $member->name . " ? new " . $member->type->name . "(init." . $member->name . ") : undefined;\n";
            }
        }

        $classBody .= $this->indent(trim($constructorContent, "\n"), 1, $options) . "\n";
        $classBody .= "}\n\n";
        $classBody .= "// <non-auto-generated-class-declarations>\n";
        if ($this->nonAutoGeneratedClassDeclarations) {
            $classBody .= $this->indent($this->nonAutoGeneratedClassDeclarations, -1, $options);
        }
        $classBody .= "\n";
        $classBody .= "// </non-auto-generated-class-declarations>";
        $content .= $this->indent($classBody, 1, $options) . "\n";
        $content .= "}\n";
        return $content;
    }
}
