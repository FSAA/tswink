<?php

namespace TsWink\Classes;

use Illuminate\Support\Str;
use Doctrine\DBAL\Connection;
use Doctrine\DBAL\Platforms\AbstractPlatform;
use Doctrine\DBAL\Schema\AbstractSchemaManager;
use Doctrine\DBAL\Schema\Table;
use TsWink\Classes\Expressions\ClassExpression;
use TsWink\Classes\Expressions\ClassMemberExpression;
use TsWink\Classes\Expressions\EnumExpression;
use TsWink\Classes\Expressions\ImportExpression;
use TsWink\Classes\Expressions\PivotExpression;
use TsWink\Classes\Expressions\TypeExpression;
use TsWink\Classes\Expressions\ExpressionStringGenerationOptions;
use TsWink\Classes\Utils\StringUtils;

use function PHPUnit\Framework\assertNotNull;

class TswinkGenerator
{
    private TypeConverter $typeConverter;

    /** @var Table[] */
    protected array $tables;

    /** @var AbstractSchemaManager<AbstractPlatform> */
    protected AbstractSchemaManager $schemaManager;

    /** @var array<string,PivotExpression> */
    private array $discoveredPivots = [];

    /** @var array<string,array<array{pivotAccessor:string,pivotExpression:PivotExpression}>> */
    private array $targetModelPivots = [];

    private bool $quiet = false;

    public function __construct(Connection $dbConnection, bool $quiet = false)
    {
        $this->typeConverter = new TypeConverter();
        $this->quiet = $quiet;

        $this->schemaManager = $dbConnection->createSchemaManager();
        $this->tables = $this->schemaManager->listTables();
    }

    /**
     * Enable or disable quiet mode
     */
    public function setQuiet(bool $quiet): self
    {
        $this->quiet = $quiet;
        return $this;
    }

    /**
     * @param string[] $sources
     */
    public function generate(array $sources, string $classesDestination, string $enumsDestination, ExpressionStringGenerationOptions $codeGenerationOptions): void
    {
        if (count($sources) == 0) {
            return;
        }

        // Pass 1: Discover all pivot information
        if (!$this->quiet) {
            echo("Pass 1: Discovering pivot information...\n");
        }
        $this->discoverPivots($sources);

        // Pass 2: Generate TypeScript files with complete pivot knowledge
        if (!$this->quiet) {
            echo("Pass 2: Generating TypeScript files...\n");
        }
        foreach ($sources as $enumsPath) {
            $files = scandir($enumsPath);
            if ($files === false) {
                continue;
            }
            foreach ($files as $file) {
                if (!$this->quiet) {
                    echo("Processing '" . $file . "'...\n");
                }
                if (pathinfo(strtolower($file), PATHINFO_EXTENSION) == 'php') {
                    $this->convertFile($enumsPath . "/" . $file, $classesDestination, $enumsDestination, $codeGenerationOptions);
                }
            }
        }

        // Generate pivot interfaces after all classes are processed
        $this->generatePivotInterfaces($classesDestination, $codeGenerationOptions);
    }

    public function convertFile(string $filePath, string $classesDestination, string $enumsDestination, ExpressionStringGenerationOptions $codeGenerationOptions): void
    {
        $class = null;
        $fileContent = file_get_contents($filePath);
        if ($fileContent && (ClassExpression::tryParse($fileContent, $class, $codeGenerationOptions) || EnumExpression::tryParse($fileContent, $class, $codeGenerationOptions))) {
            assertNotNull($class); // Since the tryParse returned true, the class is not null
            $basePath = $this->resolveDestination($class, $enumsDestination, $classesDestination);
            if ($class->baseClassName != "Enum") {
                if (!$codeGenerationOptions->useInterfaceInsteadOfClass) {
                    $this->addUuidToClass($class);
                }
                $this->addPhpQualifiedClassName($class);
                $this->mergeDatabaseSchema($class, $codeGenerationOptions);
                $this->addPivotProperties($class);
                $class->generateMembersFromDocBlock();
            }
            $fileName = $basePath . "/" . $class->name . ".ts";
            $this->mergeNonAutoGeneratedDeclarations($class, $fileName);
            $this->writeFile($fileName, $class->toTypeScript($codeGenerationOptions));
            $this->generateNewModelFile($class, $classesDestination, $codeGenerationOptions);
        }
    }

    private function generateNewModelFile(ClassExpression $class, string $basePath, ExpressionStringGenerationOptions $codeGenerationOptions): void
    {
        if (!$codeGenerationOptions->createSeparateClassForNewModels || $class->baseClassName === "Enum") {
            return;
        }
        $previousForcePropertiesOptional = $codeGenerationOptions->forcePropertiesOptional;
        $codeGenerationOptions->forcePropertiesOptional = true; // Force properties to be optional in the new class
        $fileName = $basePath . "/New" . $class->name . ".ts";
        $class->name = 'New' . $class->name;
        $class->extends = 'BaseModel';
        foreach ($class->imports as $import) {
            if (!$import->internal) {
                continue;
            }
            array_walk(
                $class->members,
                fn (ClassMemberExpression $member) => $member->types && array_walk(
                    $member->types,
                    function (TypeExpression $type) use ($import) {
                        if ($type->name === $import->name) {
                            $type->name = 'New' . $type->name;
                        }
                    }
                )
            );
            $import->target = str_replace('./', './New', $import->target);
            $import->name = 'New' . $import->name;
        }
        $class->imports[0]->name = 'BaseModel';
        $class->imports[0]->target = './BaseModel';
        $this->writeFile($fileName, $class->toTypeScript($codeGenerationOptions));
        $codeGenerationOptions->forcePropertiesOptional = $previousForcePropertiesOptional; // Restore the original setting
    }

    private function resolveDestination(ClassExpression $class, string $enumsDestination, string $classesDestination): string
    {
        if ($class->baseClassName == "Enum") {
            return $enumsDestination;
        }
        return $classesDestination;
    }

    private function addPhpQualifiedClassName(ClassExpression $class): void
    {
        $classMember = new ClassMemberExpression();
        $classMember->name = 'phpQualifiedClassName';
        $classMember->accessModifiers = 'const';
        $classMember->initialValue = "'" . addSlashes($class->fullyQualifiedClassName()) . "'";
        $type = new TypeExpression();
        $type->name = 'string';
        $type->isCollection = false;
        $classMember->types = [$type];
        $class->members[] = $classMember;
    }

    private function addUuidToClass(ClassExpression $class): void
    {
        $uuidImport = new ImportExpression();
        $uuidImport->name = "{ v4 as uuid }";
        $uuidImport->target = "uuid";
        array_push($class->imports, $uuidImport);

        $uuidClassMember = new ClassMemberExpression();
        $uuidClassMember->name = "uuid";
        $uuidClassMember->accessModifiers = "public";
        $uuidClassMember->initialValue = "uuid()";
        $uuidType = new TypeExpression();
        $uuidType->name = "string";
        $uuidType->isCollection = false;
        $uuidClassMember->types = [$uuidType];
        array_push($class->members, $uuidClassMember);
    }

    public function mergeDatabaseSchema(ClassExpression $class, ExpressionStringGenerationOptions $codeGenerationOptions): void
    {
        $instance = $class->instantiate();
        if (!method_exists($instance, "getTable")) {
            return;
        }
        $table = current(array_filter($this->tables, function ($table) use ($instance) {
            return $table->getName() == $instance->getTable();
        }));
        if ($table === false) {
            return;
        }
        foreach ($table->getColumns() as $column) {
            $classMember = ClassMemberExpression::fromColumn($column, $this->typeConverter, $codeGenerationOptions);
            $class->members[$classMember->name] = $classMember;
        }
        foreach ($class->eloquentRelations as $relation) {
            $classMember = ClassMemberExpression::fromRelation($relation, $class);
            $class->members[$classMember->name] = $classMember;
        }
    }

    /**
     * Add pivot properties to the class based on discovered pivots
     */
    private function addPivotProperties(ClassExpression $class): void
    {
        // Check if this class is a target for any pivot relations
        $pivots = $this->targetModelPivots[$class->name] ?? [];

        foreach ($pivots as $pivotInfo) {
            $this->addPivotPropertyToClass($class, $pivotInfo['pivotAccessor'], $pivotInfo['pivotExpression']);
        }
    }

    /**
     * Add a single pivot property to the class
     */
    private function addPivotPropertyToClass(ClassExpression $class, string $pivotAccessor, PivotExpression $pivotExpression): void
    {
        // Create a class member for the pivot accessor
        $classMember = new ClassMemberExpression();
        $classMember->name = Str::snake($pivotAccessor);
        $classMember->accessModifiers = 'public';
        $classMember->isOptional = true; // A pivot is always optional

        // Create type expression for the pivot interface
        $type = new TypeExpression();

        // Get required columns from the pivot expression
        $requiredColumns = $pivotExpression->getRequiredColumns();

        if (!empty($requiredColumns)) {
            // Use SetRequired type with the required columns
            $requiredColumnsString = "'" . implode("' | '", $requiredColumns) . "'";
            $type->name = "SetRequired<{$pivotExpression->interfaceName}, {$requiredColumnsString}>";

            // Add import for SetRequired
            if (!isset($class->imports['SetRequired'])) {
                $class->imports['SetRequired'] = ImportExpression::createSetRequiredImport();
            }
        } else {
            // No required columns, use the plain interface
            $type->name = $pivotExpression->interfaceName;
        }

        $type->isCollection = false;
        $classMember->types = [$type];

        // Add the member to the class
        $class->members[$classMember->name] = $classMember;

        // Add import for the pivot interface
        $pivotImport = new ImportExpression();
        $pivotImport->name = $pivotExpression->interfaceName;
        $pivotImport->target = "./" . $pivotExpression->interfaceName;
        $class->imports[$pivotImport->name] = $pivotImport;
    }

    private function mergeNonAutoGeneratedDeclarations(ClassExpression $class, string $filePath): void
    {
        if (!file_exists($filePath)) {
            return;
        }
        $fileContent = file_get_contents($filePath);
        if (!$fileContent) {
            return;
        }
        $imports = StringUtils::textBetween($fileContent, "// <non-auto-generated-import-declarations>", "// </non-auto-generated-import-declarations>");
        if ($imports) {
            $class->nonAutoGeneratedImports = trim(str_replace("\r", "", $imports), "\n");
        }
        $declarations = StringUtils::textBetween($fileContent, "// <non-auto-generated-class-declarations>", "// </non-auto-generated-class-declarations>");
        if ($declarations) {
            $class->nonAutoGeneratedClassDeclarations = trim(str_replace("\r", "", $declarations), "\n");
        }
        $declarations = StringUtils::textBetween($fileContent, "// <non-auto-generated-code>", "// </non-auto-generated-code>");
        if ($declarations) {
            $class->nonAutoGeneratedCode = trim(str_replace("\r", "", $declarations), "\n");
        }
    }

    private function writeFile(string $filePath, string $content): void
    {
        if (!file_exists(dirname($filePath))) {
            mkdir(dirname($filePath), 0770, true);
        }
        file_put_contents($filePath, $content);
    }

    /**
     * Pass 1: Discover all pivot information from all PHP files
     * @param string[] $sources
     */
    private function discoverPivots(array $sources): void
    {
        foreach ($sources as $sourcePath) {
            $files = scandir($sourcePath);
            if ($files === false) {
                continue;
            }
            foreach ($files as $file) {
                if (pathinfo(strtolower($file), PATHINFO_EXTENSION) == 'php') {
                    $this->discoverPivotsFromFile($sourcePath . "/" . $file);
                }
            }
        }
    }

    /**
     * Discover pivot information from a single PHP file
     */
    private function discoverPivotsFromFile(string $filePath): void
    {
        $class = null;
        $fileContent = file_get_contents($filePath);
        if (!$fileContent) {
            return;
        }

        // Try to parse the class to get pivot information
        if (ClassExpression::tryParse($fileContent, $class, new ExpressionStringGenerationOptions())) {
            if ($class && $class->baseClassName != "Enum") {
                foreach ($class->eloquentRelations as $relation) {
                    if ($relation->pivotAccessor !== null && $relation->pivotTable !== null) {
                        $pivotExpression = PivotExpression::fromEloquentRelation($relation, $this->tables, $this->typeConverter);
                        if ($pivotExpression && $pivotExpression->hasFields()) {
                            // Store the pivot interface
                            $this->discoveredPivots[$relation->pivotTable] = $pivotExpression;

                            // Map the pivot property to the target model
                            $targetClassName = $relation->targetClassName;
                            $targetModelName = substr($targetClassName, strrpos($targetClassName, '\\') + 1);

                            if (!isset($this->targetModelPivots[$targetModelName])) {
                                $this->targetModelPivots[$targetModelName] = [];
                            }

                            $this->targetModelPivots[$targetModelName][] = [
                                'pivotAccessor' => $relation->pivotAccessor,
                                'pivotExpression' => $pivotExpression
                            ];
                        }
                    }
                }
            }
        }
    }

    /**
     * Generate TypeScript interfaces for all discovered pivots
     */
    private function generatePivotInterfaces(string $classesDestination, ExpressionStringGenerationOptions $codeGenerationOptions): void
    {
        if (empty($this->discoveredPivots)) {
            return;
        }

        foreach ($this->discoveredPivots as $pivotExpression) {
            $fileName = $classesDestination . "/" . $pivotExpression->getFileName();
            $content = $pivotExpression->toTypeScript($codeGenerationOptions);
            $this->writeFile($fileName, $content);
            if (!$this->quiet) {
                echo("Generated pivot interface: {$fileName}\n");
            }
        }
    }
}
